#!/usr/bin/env node

const fs = require('fs');
const getMetaFile = require('get-meta-file');
const getPackageDependencies = require('../lib/getPackageDependencies');
const path = require('path');
const slash = require('slash');
const _ = require('lodash');

// a bit dicey, but getMetaFile also assumes process.cwd(), so we'll let it be for now.
const rootDir = process.cwd();

if (process.argv[2] === '--help') {
  return console.log(`\n  usage:\n\n    meta npm link-ls\n`);
} else {
  main();
}


function main() {
  var meta = getMetaFile();
  const metaLocation = path.join(process.cwd(), '.meta');
  const metaPackageJson = require(path.join(metaLocation, '..', 'package.json'));
  const packages = [];
  const projects = meta.projects;

  _.forEach(Object.keys(projects), folder => {
    const childPackageJson = require(path.join(metaLocation, '..', folder, 'package.json'));

    packages.push({
      name: childPackageJson.name,
      folder: path.join(metaLocation, '..', folder),
      dependencies: childPackageJson.dependencies,
      devDependencies: childPackageJson.devDependencies,
    });
  });

  packages.push({
    name: metaPackageJson.name,
    folder: path.join(metaLocation, '..'),
    dependencies: metaPackageJson.dependencies,
    devDependencies: metaPackageJson.devDependencies,
  });


  const dependencies = getPackageDependencies(packages);

  console.log(`\nLinked child projects (intra-meta-repo dependency listing)\n`);
  const symlinks = {}
  dependencies.forEach((dep) => {
    const dir = `${dep.targetFolder}/node_modules/${dep.source}`;
    const result = resolveSymLink(dir);

    if (result) {
      // it seems the dependencies have their source and target inverted.
      const { sourceFolder, targetFolder } = dep;
      const source = slash(path.relative(rootDir, sourceFolder));
      const target = slash(path.relative(rootDir, targetFolder));
      // if (source in symlinks) {
      //   symlinks[source] = [...symlinks[source], target]
      // } else {
      //   symlinks[source] = [target]
      // }
      if (target in symlinks) {
        symlinks[target] = [...symlinks[target], source]
      } else {
        symlinks[target] = [source]
      }
    }
  });

  const srcWidth = Object.keys(symlinks).reduce((max, s) => Math.max(max, s.length), 0);
  Object.keys(symlinks).sort().forEach((src) => {
    symlinks[src].sort().forEach((tgt) => {
      console.log(`${src.padEnd(srcWidth, ' ')} <- ${tgt}`)
    })
  })
}

function resolveSymLink(dir) {
  const stat1 = fs.lstatSync(dir);
  if (stat1.isSymbolicLink()) {
    const dir2 = fs.readlinkSync(dir);
    const stat2 = fs.lstatSync(dir2);
    if (stat2.isSymbolicLink()) {
      const target = fs.readlinkSync(dir2);
      return {
        source: slash(path.relative(rootDir, dir)),
        via: slash(dir2).replace(".*/node_modules", "[GLOBAL]"),
        target: slash(path.relative(rootDir, target))
      }
    }
  }
}